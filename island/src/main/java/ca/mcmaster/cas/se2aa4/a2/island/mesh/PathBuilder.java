package ca.mcmaster.cas.se2aa4.a2.island.mesh;
import ca.mcmaster.cas.se2aa4.a2.island.geography.Land;
import ca.mcmaster.cas.se2aa4.a2.island.tile.Tile;
import ca.mcmaster.cas.se2aa4.a2.island.tile.type.TileType;
import ca.mcmaster.cas.se2aa4.a2.mesh.adt.segment.Segment;
import ca.mcmaster.cas.se2aa4.a2.mesh.adt.vertex.Vertex;
import graph.IGraph;
import graph.UndirectedGraph;
import node.Node;
import shortestpath.DijkstraShortestPath;

import java.awt.*;
import java.util.List;

public class PathBuilder {

    /**
     *this is the builder that will be used to build the paths by calling the other functions
     * @param land the land object
     * @param islandMesh the mesh that will be used
     * @param settlements The list of settlements that was generated
     */
    public void build(Land land, IslandMesh islandMesh, List<Node<Vertex>> settlements){
        settlements.get(0).getObj().setColor(new Color(255,51,204));
        DijkstraShortestPath<Vertex> pathway = new DijkstraShortestPath<>();
        IGraph <Vertex> graph = makeGraph(land);
        for(int i = 1; i < settlements.size(); i++){
            List<Node<Vertex>> listofvertices = pathway.shortestpath(graph, settlements.get(0), settlements.get(i));
            visualizePathFinder(islandMesh, listofvertices);
        }

    }

    /**
     * this function makes the graph
     * @param land the land that will be passed in to iterate over its tiles
     * @return the graph that will be generated by the vertices of the land tiles
     */
    public IGraph<Vertex> makeGraph(Land land) {
        IGraph<Vertex> graph = new UndirectedGraph<>();

        List<Tile> tiles = land.getTiles().stream().filter(tile -> tile.getType() != TileType.OCEAN && tile.getType() != TileType.LAND_WATER).toList();
        for (Tile tile : tiles) {
            for (Segment segment : tile.getPolygon().getSegments()) {
                graph.addNode(new Node<>(segment.getV1()));
                graph.addNode(new Node<>(segment.getV2()));
                graph.addEdge(new Node<>(segment.getV1()),new Node<>(segment.getV2()), 1);
            }
        }
        return graph;
    }

    /**
     * this function is going to be used to convert the segments that are in the list of vertices returned by Dijkstra's algorithm
     * @param islandMesh the  mesh to be used
     * @param thelist list of vertices of the path
     */
    public void visualizePathFinder(IslandMesh islandMesh,List<Node<Vertex>> thelist){
        for(int i = 0; i <= thelist.size()-2; i++){
            for(Segment segment : islandMesh.getConverted().getSegments()){
                if(segment.getV1().equals(thelist.get(i).getObj()) && segment.getV2().equals(thelist.get(i+1).getObj())
               || segment.getV2().equals(thelist.get(i).getObj()) && segment.getV1().equals(thelist.get(i+1).getObj())){
                    segment.setColor(new Color(0,0,0));
                }
            }
        }
    }
}
